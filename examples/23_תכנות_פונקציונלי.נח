# ╔══════════════════════════════════════════════════════════════╗
# ║  דוגמה 23: תכנות פונקציונלי                                  ║
# ║  Example 23: Functional Programming                          ║
# ╚══════════════════════════════════════════════════════════════╝

הדפס("╔══════════════════════════════════════════╗")
הדפס("║  λ תכנות פונקציונלי בנחשון              ║")
הדפס("╚══════════════════════════════════════════╝")

# ===== פונקציות כערכים =====
הדפס("\n📦 פונקציות כערכים:")
הדפס("═" * 40)

הגדר כפול(x):
    החזר x * 2

הגדר שלש(x):
    החזר x * 3

הגדר הפעל_פונקציה(פונקציה, ערך):
    """פונקציה שמקבלת פונקציה כפרמטר"""
    החזר פונקציה(ערך)

הדפס("כפול(5) = " + מחרוזת(הפעל_פונקציה(כפול, 5)))
הדפס("שלש(5) = " + מחרוזת(הפעל_פונקציה(שלש, 5)))

# ===== למבדה - פונקציות אנונימיות =====
הדפס("\n🔧 פונקציות למבדה:")
הדפס("═" * 40)

ריבוע = למבדה x: x * x
מעוקב = למבדה x: x * x * x
חיבור = למבדה א, ב: א + ב

הדפס("ריבוע(7) = " + מחרוזת(ריבוע(7)))
הדפס("מעוקב(3) = " + מחרוזת(מעוקב(3)))
הדפס("חיבור(10, 20) = " + מחרוזת(חיבור(10, 20)))

# למבדה עם תנאי
מקסימום = למבדה א, ב: א אם א > ב אחרת ב
מינימום = למבדה א, ב: א אם א < ב אחרת ב
ערך_מוחלט = למבדה x: x אם x >= 0 אחרת -x

הדפס("מקסימום(15, 8) = " + מחרוזת(מקסימום(15, 8)))
הדפס("ערך_מוחלט(-42) = " + מחרוזת(ערך_מוחלט(-42)))

# ===== מפה (Map) =====
הדפס("\n🗺️ פונקציית מפה (Map):")
הדפס("═" * 40)

מספרים = [1, 2, 3, 4, 5]
הדפס("מספרים מקוריים: " + מחרוזת(מספרים))

# הכפלה
כפולים = רשימה(מפה(למבדה x: x * 2, מספרים))
הדפס("כפול כל מספר: " + מחרוזת(כפולים))

# ריבועים
ריבועים = רשימה(מפה(למבדה x: x * x, מספרים))
הדפס("ריבוע כל מספר: " + מחרוזת(ריבועים))

# המרה למחרוזות
מחרוזות = רשימה(מפה(מחרוזת, מספרים))
הדפס("כמחרוזות: " + מחרוזת(מחרוזות))

# ===== סינון (Filter) =====
הדפס("\n🔍 פונקציית סינון (Filter):")
הדפס("═" * 40)

מספרים = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
הדפס("מספרים: " + מחרוזת(מספרים))

# מספרים זוגיים
זוגיים = רשימה(סנן(למבדה x: x % 2 == 0, מספרים))
הדפס("זוגיים: " + מחרוזת(זוגיים))

# מספרים אי-זוגיים
אי_זוגיים = רשימה(סנן(למבדה x: x % 2 != 0, מספרים))
הדפס("אי-זוגיים: " + מחרוזת(אי_זוגיים))

# מספרים גדולים מ-5
גדולים = רשימה(סנן(למבדה x: x > 5, מספרים))
הדפס("גדולים מ-5: " + מחרוזת(גדולים))

# ===== שרשור מפה וסינון =====
הדפס("\n🔗 שרשור פעולות:")
הדפס("═" * 40)

מספרים = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# סנן זוגיים, ואז הכפל
תוצאה = רשימה(מפה(למבדה x: x * 2, סנן(למבדה x: x % 2 == 0, מספרים)))
הדפס("זוגיים × 2: " + מחרוזת(תוצאה))

# ריבועים של אי-זוגיים
תוצאה2 = רשימה(מפה(למבדה x: x * x, סנן(למבדה x: x % 2 != 0, מספרים)))
הדפס("ריבועי אי-זוגיים: " + מחרוזת(תוצאה2))

# ===== הבנת רשימות (List Comprehension) =====
הדפס("\n📝 הבנת רשימות:")
הדפס("═" * 40)

# בסיסי
ריבועים = [x * x עבור x בתוך טווח(1, 6)]
הדפס("ריבועים 1-5: " + מחרוזת(ריבועים))

# עם תנאי
זוגיים = [x עבור x בתוך טווח(1, 11) אם x % 2 == 0]
הדפס("זוגיים 1-10: " + מחרוזת(זוגיים))

# מורכב
מורכב = [x * 2 עבור x בתוך טווח(1, 11) אם x % 2 != 0]
הדפס("אי-זוגיים × 2: " + מחרוזת(מורכב))

# ===== פונקציות מסדר גבוה מותאמות =====
הדפס("\n🏗️ פונקציות מסדר גבוה:")
הדפס("═" * 40)

הגדר הרכב(f, g):
    """הרכבת שתי פונקציות: (f ∘ g)(x) = f(g(x))"""
    החזר למבדה x: f(g(x))

הגדר חיבור_5(x):
    החזר x + 5

הגדר כפול_2(x):
    החזר x * 2

# (x * 2) + 5
כפול_אז_חבר = הרכב(חיבור_5, כפול_2)
# (x + 5) * 2
חבר_אז_כפול = הרכב(כפול_2, חיבור_5)

הדפס("כפול_אז_חבר(10) = (10 * 2) + 5 = " + מחרוזת(כפול_אז_חבר(10)))
הדפס("חבר_אז_כפול(10) = (10 + 5) * 2 = " + מחרוזת(חבר_אז_כפול(10)))

# ===== Curry =====
הדפס("\n🍛 קארי (Currying):")
הדפס("═" * 40)

הגדר חיבור_קארי(א):
    """פונקציה שמחזירה פונקציה"""
    החזר למבדה ב: א + ב

הוסף_10 = חיבור_קארי(10)
הוסף_100 = חיבור_קארי(100)

הדפס("הוסף_10(5) = " + מחרוזת(הוסף_10(5)))
הדפס("הוסף_100(5) = " + מחרוזת(הוסף_100(5)))

הגדר כפל_קארי(א):
    החזר למבדה ב: א * ב

כפול_ב_3 = כפל_קארי(3)
כפול_ב_10 = כפל_קארי(10)

הדפס("כפול_ב_3(7) = " + מחרוזת(כפול_ב_3(7)))
הדפס("כפול_ב_10(7) = " + מחרוזת(כפול_ב_10(7)))

# ===== Reduce / Fold =====
הדפס("\n➕ צמצום (Reduce):")
הדפס("═" * 40)

הגדר צמצם(פונקציה, רשימה, התחלה):
    """צמצום רשימה לערך בודד"""
    מצבר = התחלה
    עבור איבר בתוך רשימה:
        מצבר = פונקציה(מצבר, איבר)
    החזר מצבר

מספרים = [1, 2, 3, 4, 5]

# סכום
סכום = צמצם(למבדה א, ב: א + ב, מספרים, 0)
הדפס("סכום [1,2,3,4,5] = " + מחרוזת(סכום))

# מכפלה
מכפלה = צמצם(למבדה א, ב: א * ב, מספרים, 1)
הדפס("מכפלה [1,2,3,4,5] = " + מחרוזת(מכפלה))

# מקסימום
מקס = צמצם(למבדה א, ב: א אם א > ב אחרת ב, מספרים, מספרים[0])
הדפס("מקסימום [1,2,3,4,5] = " + מחרוזת(מקס))

# שרשור מחרוזות
מילים = ["שלום", " ", "עולם", "!"]
משפט = צמצם(למבדה א, ב: א + ב, מילים, "")
הדפס("שרשור: " + משפט)

# ===== Pipeline / Pipe =====
הדפס("\n🔄 צינור עיבוד (Pipeline):")
הדפס("═" * 40)

הגדר צינור(ערך, *פונקציות):
    """העבר ערך דרך סדרת פונקציות"""
    תוצאה = ערך
    עבור פ בתוך פונקציות:
        תוצאה = פ(תוצאה)
    החזר תוצאה

# דוגמה: x -> +3 -> *2 -> **2
תוצאה = צינור(5, למבדה x: x + 3, למבדה x: x * 2, למבדה x: x * x)
הדפס("צינור(5, +3, *2, ^2) = " + מחרוזת(תוצאה))
הדפס("  (5 + 3) = 8")
הדפס("  (8 * 2) = 16") 
הדפס("  (16 * 16) = 256")

# ===== Memoization =====
הדפס("\n💾 זכירה (Memoization):")
הדפס("═" * 40)

הגדר צור_עם_זיכרון(פונקציה):
    """עטיפת פונקציה עם זיכרון מטמון"""
    מטמון = {}
    
    הגדר פונקציה_עם_זיכרון(n):
        אם n לא בתוך מטמון:
            מטמון[n] = פונקציה(n)
        החזר מטמון[n]
    
    החזר פונקציה_עם_זיכרון

הגדר פיבונאצי_איטי(n):
    """פיבונאצ'י ללא אופטימיזציה"""
    אם n <= 1:
        החזר n
    החזר פיבונאצי_איטי(n - 1) + פיבונאצי_איטי(n - 2)

# יצירת גרסה עם זיכרון
פיבונאצי_מהיר = צור_עם_זיכרון(למבדה n: n אם n <= 1 אחרת פיבונאצי_מהיר(n-1) + פיבונאצי_מהיר(n-2))

הדפס("פיבונאצ'י עם זיכרון:")
עבור א בתוך [10, 20, 30]:
    הדפס("  fib(" + מחרוזת(א) + ") = " + מחרוזת(פיבונאצי_מהיר(א)))

הדפס("\n✨ סיום דוגמת תכנות פונקציונלי!")
